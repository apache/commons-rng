/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.commons.rng.simple;

import org.apache.commons.rng.UniformRandomProvider;
import org.apache.commons.rng.core.source32.IntProvider;
import org.apache.commons.rng.core.source64.LongProvider;

/**
 * Factory class for wrapping instances of {@link UniformRandomProvider} to cache
 * values that can be reused to provision the interface methods.
 *
 * <p>The int values generated by an {@link IntProvider} can be cached to enable
 * fast provision of {@link UniformRandomProvider#nextBoolean()}.

 * <p>The long values generated by a {@link LongProvider} can be cached to enable
 * fast provision of {@link UniformRandomProvider#nextBoolean()} and
 * {@link UniformRandomProvider#nextInt()}.
 */
public final class CachedUniformRandomProviderFactory {

    /**
     * Class contains only static methods.
     */
    private CachedUniformRandomProviderFactory() {}

    /**
     * Marker interface to avoid double wrapping a Cached provider.
     */
    private interface CachedUniformRandomProvider {
        // Marker interface
    }

    /**
     * Wrap an IntProvider instance to enable fast provision of
     * {@link UniformRandomProvider#nextBoolean()}.
     */
    static final class CachedIntProvider
        extends IntProvider
        implements CachedUniformRandomProvider {

        /** The underlying source of randomness. */
        private final UniformRandomProvider rng;

        /**
         * Provides a bit source for booleans.
         *
         * <p>A cached value from a call to random {@link UniformRandomProvider#nextInt()}.
         */
        private int booleanSource; // Initialised as 0

        /**
         * The bit mask of the boolean source to obtain the boolean bit.
         *
         * <p>The bit mask contains a single bit set.
         * This begins at the least significant bit and is gradually shifted
         * upwards until overflow to zero. 
         * 
         * <p>When zero a new boolean source should be created and the mask 
         * set to the least significant bit (i.e. 1).
         */
        private int booleanBitMask; // Initialised as 0

        /**
         * Create a new instance.
         *
         * @param rng the source of randomness
         */
        CachedIntProvider(IntProvider rng) {
            this.rng = rng;
        }

        @Override
        public int next() {
            // Delegate this
            return rng.nextInt();
        }

        @Override
        public boolean nextBoolean() {
            // Shift up. This will eventually overflow and become zero.
            booleanBitMask <<= 1;
            // The mask will either contain a single bit or none.
            if (booleanBitMask == 0) {
                // Set the least significant bit
                booleanBitMask = 1;
                // Get the next value
                booleanSource = rng.nextInt();
            }
            // Return if the bit is set
            return (booleanSource & booleanBitMask) != 0;
        }
    }

    /**
     * Wrap an IntProvider instance to enable fast provision of
     * {@link UniformRandomProvider#nextBoolean()}.
     */
    static final class CachedIntProvider2
        extends IntProvider
        implements CachedUniformRandomProvider {

        /** The underlying source of randomness. */
        private final UniformRandomProvider rng;

        /**
         * Provides a bit source for booleans.
         *
         * <p>A cached value from a call to random {@link UniformRandomProvider#nextInt()}.
         */
        private int booleanSource; // Initialised as 0

        /**
         * The number of significant bits to discard.
         *
         * <p>The significant bits are discarded using a shift up. This is used
         * with values from 31 to 1. When zero a new boolean source is generated.
         */
        private int discardShift; // Initialised as 0

        /**
         * Create a new instance.
         *
         * @param rng the source of randomness
         */
        CachedIntProvider2(IntProvider rng) {
            this.rng = rng;
        }

        @Override
        public int next() {
            // Delegate this
            return rng.nextInt();
        }

        @Override
        public boolean nextBoolean() {
            // Check the current shift.
            // In multi-thread use the decrement can pass zero
            // so use <= and not ==.
            // Note: Current RNG are not thread safe though.
            if (--discardShift <= 0) {
                // Set shift to the size of an int
                discardShift = Integer.SIZE;
                // Get the next value
                booleanSource = rng.nextInt();
                // Check the most significant bit
                return (booleanSource >>> 31) != 0;
            }
            // The discard shift is in the range 31 to 1
            return ((booleanSource << discardShift) >>> 31) != 0;
        }
    }


    /**
     * Wrap an IntProvider instance to enable fast provision of
     * {@link UniformRandomProvider#nextBoolean()}.
     */
    static final class CachedIntProvider3
        extends IntProvider
        implements CachedUniformRandomProvider {

        /** The underlying source of randomness. */
        private final UniformRandomProvider rng;

        /**
         * Provides a bit source for booleans.
         *
         * <p>A cached value from a call to random {@link UniformRandomProvider#nextInt()}.
         */
        private int booleanSource; // Initialised as 0

        /**
         * The number of significant bits to discard.
         *
         * <p>The significant bits are discarded using a shift up. This is used
         * with values from 31 to 1. When zero a new boolean source is generated.
         */
        private int discardShift; // Initialised as 0

        /**
         * Create a new instance.
         *
         * @param rng the source of randomness
         */
        CachedIntProvider3(IntProvider rng) {
            this.rng = rng;
        }

        @Override
        public int next() {
            // Delegate this
            return rng.nextInt();
        }

        @Override
        public boolean nextBoolean() {
            // Check the current shift.
            // In multi-thread use the decrement can pass zero
            // so use <= and not ==.
            // Note: Current RNG are not thread safe though.
            if (discardShift <= 0) {
                // Set to the bit size of an int
                discardShift = Integer.SIZE;
                // Get the next value
                booleanSource = rng.nextInt();
            }
            return ((booleanSource << --discardShift) >>> 31) != 0;
        }
    }

    /**
     * Wrap an IntProvider instance to enable fast provision of
     * {@link UniformRandomProvider#nextBoolean()}.
     */
    static final class CachedIntProvider4
        extends IntProvider
        implements CachedUniformRandomProvider {

        /** The underlying source of randomness. */
        private final UniformRandomProvider rng;

        /**
         * Provides a bit source for booleans.
         *
         * <p>A cached value from a call to random {@link UniformRandomProvider#nextInt()}.
         */
        private int booleanSource; // Initialised as 0

        /**
         * A count of the number of bits used in the boolean source.
         *
         * <p>This is initialised using the least significant bit and gradually 
         * shifted up until overflow resets it to zero.
         */
        private int shiftCounter; // Initialised as 0

        /**
         * Create a new instance.
         *
         * @param rng the source of randomness
         */
        CachedIntProvider4(IntProvider rng) {
            this.rng = rng;
        }

        @Override
        public int next() {
            // Delegate this
            return rng.nextInt();
        }

        @Override
        public boolean nextBoolean() {
            // Shift up. This will eventually reset to zero.
            shiftCounter <<= 1;
            if (shiftCounter == 0) {
                // Set the counter least significant bit
                shiftCounter = 1;
                // Get the next value
                booleanSource = rng.nextInt();
            } else {
                // Consume the last used most significant bit from the source
                booleanSource <<= 1;
            }
            // Return the boolean using the most significant bit.
            return (booleanSource >>> 31) != 0;
        }
    }

    /**
     * Wrap a LongProvider instance to enable fast provision of
     * {@link UniformRandomProvider#nextBoolean()}.
     */
    static final class CachedLongProvider
        extends LongProvider
        implements CachedUniformRandomProvider {

        /** The underlying source of randomness. */
        private final UniformRandomProvider rng;

        /**
         * Provides a bit source for booleans.
         *
         * <p>A cached value from a call to random {@link UniformRandomProvider#nextLong()}.
         */
        private long booleanSource; // Initialised as 0

        /**
         * The bit mask of the boolean source to obtain the boolean bit.
         *
         * <p>The bit mask contains a single bit set.
         * This begins at the least significant bit and is gradually shifted
         * upwards until overflow to zero. 
         * 
         * <p>When zero a new boolean source should be created and the mask 
         * set to the least significant bit (i.e. 1).
         */
        private long booleanBitMask; // Initialised as 0

        /**
         * Provides a source for ints.
         *
         * <p>A cached value from a call to random {@link UniformRandomProvider#nextLong()}.
         */
        private long intSource;

        /** Flag to indicate an int source has been cached. */
        private boolean cachedIntSource; // Initialised as false

        /**
         * Create a new instance.
         *
         * @param rng the source of randomness
         */
        CachedLongProvider(LongProvider rng) {
            this.rng = rng;
        }

        @Override
        public long next() {
            // Delegate this
            return rng.nextLong();
        }

        @Override
        public boolean nextBoolean() {
            // Shift up. This will eventually overflow and become zero.
            booleanBitMask <<= 1;
            // The mask will either contain a single bit or none.
            if (booleanBitMask == 0) {
                // Set the least significant bit
                booleanBitMask = 1;
                // Get the next value
                booleanSource = rng.nextLong();
            }
            // Return if the bit is set
            return (booleanSource & booleanBitMask) != 0;
        }

        @Override
        public int nextInt() {
            // Directly store and use the long value as a source for ints
            if (cachedIntSource) {
                // Consume the cache value
                cachedIntSource = false;
                // Return the lower 32 bits
                return (int) intSource;
            }
            // Fill the cache
            cachedIntSource = true;
            intSource = rng.nextLong();
            // Return the upper 32 bits
            return (int) (intSource >>> Integer.SIZE);
        }
    }

    /**
     * Wrap a LongProvider instance to enable fast provision of
     * {@link UniformRandomProvider#nextBoolean()}.
     *
     * <p>This class exists for testing the nextBoolean() using a cached nextInt().
     */
    static final class CachedLongProvider2
        extends LongProvider
        implements CachedUniformRandomProvider {

        /** The underlying source of randomness. */
        private final UniformRandomProvider rng;

        /**
         * Provides a bit source for booleans.
         *
         * <p>A cached value from a call to random {@link UniformRandomProvider#nextLong()}.
         */
        private long booleanSource; // Initialised as 0

        /**
         * The number of significant bits to discard.
         *
         * <p>The significant bits are discarded using a shift up. This is used
         * with values from 63 to 1. When zero a new boolean source is generated.
         */
        private int discardShift; // Initialised as 0

        /** The upper 32-bits from a call to {@link UniformRandomProvider#nextLong()}. */
        private int nextIntValue;

        /** Flag to indicate an int value has been cached. */
        private boolean cachedIntValue; // Initialised as false

        /**
         * Create a new instance.
         *
         * @param rng the source of randomness
         */
        CachedLongProvider2(LongProvider rng) {
            this.rng = rng;
        }

        @Override
        public long next() {
            // Delegate this
            return rng.nextLong();
        }

        @Override
        public boolean nextBoolean() {
            // Check the current shift.
            // In multi-thread use the decrement can pass zero
            // so use <= and not ==.
            // Note: Current RNG are not thread safe though.
            if (--discardShift <= 0) {
                // Set shift to the size of a long
                discardShift = Long.SIZE;
                // Get the next value
                booleanSource = rng.nextLong();
                // Check the most significant bit
                return (booleanSource >>> 63) != 0;
            }
            // The discard shift is in the range 63 to 1
            return ((booleanSource << discardShift) >>> 63) != 0;
        }

        @Override
        public int nextInt() {
            // Cache a computed int value
            if (cachedIntValue) {
                // Consume the cache value
                cachedIntValue = false;
                return nextIntValue;
            }
            cachedIntValue = true;
            // Split a 64-bit long into two 32-bit int values
            final long sample = rng.nextLong();
            // Cache one value
            nextIntValue = (int) sample;
            // Return the other
            return (int) (sample >>> Integer.SIZE);
        }
    }

    /**
     * Wrap a LongProvider instance to enable fast provision of
     * {@link UniformRandomProvider#nextBoolean()}.
     */
    static final class CachedLongProvider3
        extends LongProvider
        implements CachedUniformRandomProvider {

        /** The underlying source of randomness. */
        private final UniformRandomProvider rng;

        /**
         * Provides a bit source for booleans.
         *
         * <p>A cached value from a call to random {@link UniformRandomProvider#nextLong()}.
         */
        private long booleanSource; // Initialised as 0

        /**
         * The number of significant bits to discard.
         *
         * <p>The significant bits are discarded using a shift up. This is used
         * with values from 63 to 1. When zero a new boolean source is generated.
         */
        private int discardShift; // Initialised as 0

        /**
         * Provides a source for ints.
         *
         * <p>A cached value from a call to random {@link UniformRandomProvider#nextLong()}.
         */
        private long intSource;

        /** A cyclic linked list for {@code int} generation. */
        private NextIntNode nextIntNode;

        /**
         * Base node for constructing a cyclic linked list for {@code int} generation.
         */
        private abstract class NextIntNode {
            /** The next node in the cyclic linked-list. */
            private NextIntNode next;
            /**
             * Get the next int sample.
             *
             * @return the int
             */
            abstract int nextInt();
            /**
             * Gets the next node.
             *
             * @return the next
             */
            NextIntNode getNext() {
                return next;
            }
            /**
             * Sets the next node.
             *
             * @param next the new next
             */
            void setNext(NextIntNode next) {
                this.next = next;
            }
        }

        /**
         * The generator node that creates the {@code int} values.
         */
        private final class GeneratorNextIntNode extends NextIntNode {
            @Override
            int nextInt() {
                intSource = rng.nextLong();
                // Return the upper 32 bits
                return (int) (intSource >>> Integer.SIZE);
            }
        }

        /**
         * The cached node that uses the generated {@code int} values.
         */
        private final class CachedNextIntNode extends NextIntNode {
            @Override
            int nextInt() {
                // Return the upper 32 bits
                return (int) (intSource >>> Integer.SIZE);
            }
        }

        /**
         * Create a new instance.
         *
         * @param rng the source of randomness
         */
        CachedLongProvider3(LongProvider rng) {
            this.rng = rng;
            // Create the cyclic linked list.
            // This is only two nodes.
            NextIntNode head = new GeneratorNextIntNode();
            NextIntNode tail = new CachedNextIntNode();
            head.setNext(tail);
            tail.setNext(head);
            // Ensure that the first move is to the head generator node
            this.nextIntNode = tail;
        }

        @Override
        public long next() {
            // Delegate this
            return rng.nextLong();
        }

        @Override
        public boolean nextBoolean() {
            // Check the current shift.
            // In multi-thread use the decrement can pass zero
            // so use <= and not ==.
            // Note: Current RNG are not thread safe though.
            if (discardShift <= 0) {
                // Set to the bit size of an long
                discardShift = Long.SIZE;
                // Get the next value
                booleanSource = rng.nextLong();
            }
            return ((booleanSource << --discardShift) >>> 63) != 0;
        }

        @Override
        public int nextInt() {
            // Use the cyclic linked-list
            nextIntNode = nextIntNode.getNext();
            return nextIntNode.nextInt();
        }
    }

    /**
     * Wrap a LongProvider instance to enable fast provision of
     * {@link UniformRandomProvider#nextBoolean()}.
     */
    static final class CachedLongProvider4
        extends LongProvider
        implements CachedUniformRandomProvider {

        /** The underlying source of randomness. */
        private final UniformRandomProvider rng;

        /**
         * Provides a bit source for booleans.
         * 
         * <p>The cached value from a call to random UniformRandomProvider#nextLong().
         */
        private long booleanSource; // Initialised as 0

        /**
         * A count of the number of bits used in the boolean source.
         *
         * <p>This is initialised using the least significant bit and gradually 
         * shifted up until overflow resets it to zero.
         */
        private long shiftCounter; // Initialised as 0

        /**
         * Provides a source for ints.
         *
         * <p>A cached value from a call to random {@link UniformRandomProvider#nextLong()}.
         */
        private long intSource;

        /** Flag to indicate a long value has been cached. */
        private boolean cachedIntSource; // Initialised as false

        /**
         * Create a new instance.
         *
         * @param rng the source of randomness
         */
        CachedLongProvider4(LongProvider rng) {
            this.rng = rng;
        }

        @Override
        public long next() {
            // Delegate this
            return rng.nextLong();
        }

        @Override
        public boolean nextBoolean() {
            // Shift up. This will eventually reset to zero.
            shiftCounter <<= 1;
            if (shiftCounter == 0) {
                // Set the counter least significant bit
                shiftCounter = 1;
                // Get the next value
                booleanSource = rng.nextInt();
            } else {
                // Consume the last used most significant bit from the source
                booleanSource <<= 1;
            }
            // Return the boolean using the most significant bit.
            return (booleanSource >>> 63) != 0;
        }

        @Override
        public int nextInt() {
            // Same as method 1 (consistency test)

            // Directly store and use the long value as a source for ints 
            if (cachedIntSource) {
                // Consume the cache value
                cachedIntSource = false;
                // Return the lower 32 bits
                return (int) intSource;
            }
            // Fill the cache
            cachedIntSource = true;
            intSource = rng.nextLong();
            // Return the upper 32 bits
            return (int) (intSource >>> Integer.SIZE);
        }
    }

    /**
     * Wrap the source of randomness.
     *
     * <p>The returned provider will cache values from an {@link IntProvider} or
     * {@link LongProvider} to enable fast provision of {@link UniformRandomProvider#nextBoolean()},
     * and in the case of a {@link LongProvider} also {@link UniformRandomProvider#nextInt()}.
     *
     * <p>If the source of randomness cannot be wrapped then it is returned unmodified.
     *
     * @param rng the source of randomness
     * @return the wrapped uniform random provider
     */
    public static UniformRandomProvider wrap(UniformRandomProvider rng) {
        return wrap(rng, 1);
    }

    /**
     * Wrap the source of randomness.
     *
     * <p>The returned provider will cache values from an {@link IntProvider} or
     * {@link LongProvider} to enable fast provision of {@link UniformRandomProvider#nextBoolean()},
     * and in the case of a {@link LongProvider} also {@link UniformRandomProvider#nextInt()}.
     *
     * <p>If the source of randomness cannot be wrapped then it is returned unmodified.
     *
     * @param rng the source of randomness
     * @param method the method
     * @return the wrapped uniform random provider
     */
    public static UniformRandomProvider wrap(UniformRandomProvider rng, int method) {
        // Avoid double wrapping
        if (rng instanceof CachedUniformRandomProvider) {
            return rng;
        }
        if (rng instanceof LongProvider) {
            switch (method) {
                case 4:
                    return new CachedLongProvider4((LongProvider)rng);
                case 3:
                    return new CachedLongProvider3((LongProvider)rng);
                case 2:
                    return new CachedLongProvider2((LongProvider)rng);
                case 1:
                    return new CachedLongProvider((LongProvider)rng);
                default:
                    throw new IllegalStateException("not implemented");
            }
        }
        if (rng instanceof IntProvider) {
            switch (method) {
                case 4:
                    return new CachedIntProvider4((IntProvider)rng);
                case 3:
                    return new CachedIntProvider3((IntProvider)rng);
                case 2:
                    return new CachedIntProvider2((IntProvider)rng);
                case 1:
                    return new CachedIntProvider((IntProvider)rng);
                default:
                    throw new IllegalStateException("not implemented");
            }
        }
        // Unknown implementation
        return rng;
    }
}
